% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seqArchR_auxiliary_functionsII.R
\name{set_config}
\alias{set_config}
\title{Set seqArchR run configuration}
\usage{
set_config(
  chunk_size = 500,
  k_min = 1,
  k_max = 50,
  mod_sel_type = "stability",
  bound = 10^-6,
  cv_folds = 5,
  parallelize = FALSE,
  n_cores = NA,
  n_runs = 100,
  alpha_base = 0,
  alpha_pow = 1,
  min_size = 25,
  result_aggl = "complete",
  result_dist = "euclid",
  checkpointing = TRUE,
  flags = list(debug = FALSE, time = FALSE, verbose = TRUE, plot = FALSE)
)
}
\arguments{
\item{chunk_size}{Numeric. Specify the size of the inner chunks of
sequences.}

\item{k_min}{Numeric. Specify the minimum of the range of values to be tested
for number of NMF basis vectors. Default is 1.}

\item{k_max}{Numeric. Specify the maximum of the range of values to be tested
for number of NMF basis vectors. Default is 50.}

\item{mod_sel_type}{Character. Specify the model selection strategy to
be used. Default is 'stability'. Another option is 'cv', short for
cross-validation. Warning: The cross-validation approach can be time
consuming and computationally expensive than the stability-based approach.}

\item{bound}{Numeric. Specify the lower bound value as criterion for choosing
the most appropriate number of NMF factors. Default is 1e-08.}

\item{cv_folds}{Numeric. Specify the number of cross-validation folds used
for model selection. Only used when mod_sel_type is set to 'cv'. Default
value is 5.}

\item{parallelize}{Logical. Specify whether to parallelize the procedure.
Note that running seqArchR serially can be time consuming, especially when
using cross-validation for model selection. See `n_cores`.
Consider parallelizing with at least 2 or 4 cores.}

\item{n_cores}{The number of cores to be used when `parallelize` is set
to TRUE. If `parallelize` is FALSE, nCores is ignored.}

\item{n_runs}{Numeric. Specify the number of bootstrapped runs
to be performed with NMF. Default value is 100. When using cross-validation
more than 100 iterations may be needed (upto 500).}

\item{alpha_base, alpha_pow}{Specify the base and the power for computing
'alpha' in performing model selection for NMF. alpha = alpha_base^alpha_pow.
Alpha specifies the regularization for NMF. Default: 0 and 1 respectively.
_Warning_: Currently, not used (for future).}

\item{min_size}{Numeric. Specify the minimum number of sequences, such that
any cluster/chunk of size less than or equal to it will not be further
processed. Default is 25.}

\item{result_aggl}{Character. Specify the agglomeration method to be used
for final result collation with hierarchical clustering. Default is
'complete' linkage. Possible values are those allowed with
\code{\link[stats]{hclust}}. Also see details below.}

\item{result_dist}{Character. Specify the distance method to be used for
final result collation with hierarchical clustering. Default is 'cor' for
correlation. Possible values are those allowed with
\code{\link[stats]{hclust}}. Also see details below.}

\item{checkpointing}{Logical. Specify whether to write intermediate
checkpoints to disk as RDS files. Checkpoints and the final result are
saved to disk provided the `o_dir` argument is set in \code{\link{seqArchR}}.
When `o_dir` argument is not provided or NULL, this is ignored.
Default is TRUE.}

\item{flags}{List with four logical elements as detailed.
\describe{
  \item{debug}{Whether debug information for the run is printed}
  \item{verbose}{Whether verbose information for the run is printed}
  \item{plot}{Whether verbose plotting is performed for the run}
  \item{time}{Whether timing information is printed for the run}
}}
}
\value{
A list with all params for seqArchR set
}
\description{
This function sets the configuration for `seqArchR`.
}
\details{
Setting suitable values for the following parameters is dependent
on the data: 'inner_chunk_size', 'k_min', 'k_max', 'mod_sel_type',
'min_size', 'result_aggl', 'result_dist'.
}
\examples{
# Set seqArchR configuration
seqArchRconfig <- seqArchR::set_config(
    chunk_size = 100,
    parallelize = TRUE,
    n_cores = 2,
    n_runs = 100,
    k_min = 1,
    k_max = 20,
    mod_sel_type = "stability",
    bound = 10^-8,
    flags = list(debug = FALSE, time = TRUE, verbose = TRUE,
        plot = FALSE)
)


}
